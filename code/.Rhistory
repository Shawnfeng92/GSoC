message(c("overall elapsed time:",end_t-start_t))
class(out_list)<-c("optimize.portfolio.rebalancing")
return(out_list)
}
#' Portfolio Optimization with Rebalancing Periods
#'
#' Portfolio optimization with support for rebalancing periods for
#' out-of-sample testing (i.e. backtesting)
#'
#' @details
#' Run portfolio optimization with periodic rebalancing at specified time periods.
#' Running the portfolio optimization with periodic rebalancing can help
#' refine the constraints and objectives by evaluating the out of sample
#' performance of the portfolio based on historical data
#'
#' This function is a essentially a wrapper around \code{optimize.portfolio}
#' and thus the discussion in the Details section of the
#' \code{optimize.portfolio} help file is valid here as well.
#'
#' This function is massively parallel and requires the 'foreach' package. It
#' is suggested to register a parallel backend.
#'
#' @param R an xts, vector, matrix, data frame, timeSeries or zoo object of asset returns
#' @param portfolio an object of type "portfolio" specifying the constraints
#' and objectives for the optimization
#' @param constraints default NULL, a list of constraint objects
#' @param objectives default NULL, a list of objective objects
#' @param optimize_method one of "DEoptim", "random", "pso", "GenSA", or "ROI"
#' @param search_size integer, how many portfolios to test, default 20,000
#' @param trace TRUE/FALSE if TRUE will attempt to return additional
#' information on the path or portfolios searched
#' @param \dots any other passthru parameters to \code{\link{optimize.portfolio}}
#' @param rp a set of random portfolios passed into the function to prevent recalculation
#' @param rebalance_on character string of period to rebalance on. See
#' \code{\link[xts]{endpoints}} for valid names.
#' @param training_period an integer of the number of periods to use as
#' a training data in the front of the returns data
#' @param trailing_periods an integer with the number of periods to roll over
#' (i.e. width of the moving or rolling window), the default is NULL will
#' run using the returns data from inception
#' @return a list containing the following elements
#' \itemize{
#'   \item{\code{portfolio}:}{ The portfolio object.}
#'   \item{\code{R}:}{ The asset returns.}
#'   \item{\code{call}:}{ The function call.}
#'   \item{\code{elapsed_time:}}{ The amount of time that elapses while the
#'   optimization is run.}
#'   \item{\code{opt_rebalancing:}}{ A list of \code{optimize.portfolio}
#'   objects computed at each rebalancing period.}
#' }
#' @author Kris Boudt, Peter Carl, Brian G. Peterson
#' @name optimize.portfolio.rebalancing
#' @aliases optimize.portfolio.rebalancing optimize.portfolio.rebalancing_v1
#' @seealso \code{\link{portfolio.spec}} \code{\link{optimize.portfolio}}
#' @examples
#' \dontrun{
#' data(edhec)
#' R <- edhec[,1:4]
#' funds <- colnames(R)
#'
#' portf <- portfolio.spec(funds)
#' portf <- add.constraint(portf, type="full_investment")
#' portf <- add.constraint(portf, type="long_only")
#' portf <- add.objective(portf, type="risk", name="StdDev")
#'
#' # Quarterly rebalancing with 5 year training period
#' bt.opt1 <- optimize.portfolio.rebalancing(R, portf,
#' optimize_method="ROI",
#' rebalance_on="quarters",
#' training_period=60)
#'
#' # Monthly rebalancing with 5 year training period and 4 year trailing (moving window)
#' bt.opt2 <- optimize.portfolio.rebalancing(R, portf,
#' optimize_method="ROI",
#' rebalance_on="months",
#' training_period=60,
#' trailing_period=48)
#' }
#' @export
optimize.portfolio.rebalancing <- function(R, portfolio=NULL, constraints=NULL, objectives=NULL, optimize_method=c("DEoptim","random","ROI"), search_size=20000, trace=FALSE, ..., rp=NULL, rebalance_on=NULL, training_period=NULL, trailing_periods=NULL)
{
stopifnot("package:foreach" %in% search() || require("foreach",quietly=TRUE))
stopifnot("package:iterators" %in% search() || require("iterators",quietly=TRUE))
# This is the case where the user has passed in a list of portfolio objects
# for the portfolio argument.
# Loop through the portfolio list and recursively call
# optimize.portfolio.rebalancing.
#Note that I return at the end of this block. I know it is not good practice
# to return before the end of a function, but I am not sure of another way
# to handle a list of portfolio objects with the recursive call to
# optimize.portfolio.
if(inherits(portfolio, "portfolio.list")){
n.portf <- length(portfolio)
opt.list <- vector("list", n.portf)
for(i in 1:length(opt.list)){
if(hasArg(message)) message=match.call(expand.dots=TRUE)$message else message=FALSE
if(message) cat("Starting optimization of portfolio ", i, "\n")
opt.list[[i]] <- optimize.portfolio.rebalancing(R=R,
portfolio=portfolio[[i]],
constraints=constraints,
objectives=objectives,
optimize_method=optimize_method,
search_size=search_size,
trace=trace,
...=...,
rp=rp,
rebalance_on=rebalance_on,
training_period=training_period,
trailing_periods=trailing_periods)
}
out <- combine.optimizations(opt.list)
class(out) <- "opt.rebal.list"
##### return here for portfolio.list because this is a recursive call
##### for optimize.portfolio.rebalancing
return(out)
}
# Store the call to return later
call <- match.call()
start_t<-Sys.time()
if (!is.null(portfolio) & !is.portfolio(portfolio)){
stop("you must pass in an object of class 'portfolio' to control the optimization")
}
if(hasArg(message)) message=match.call(expand.dots=TRUE)$message else message=FALSE
# Check for constraints and objectives passed in separately outside of the portfolio object
if(!is.null(constraints)){
if(inherits(constraints, "v1_constraint")){
if(is.null(portfolio)){
# If the user has not passed in a portfolio, we will create one for them
tmp_portf <- portfolio.spec(assets=constraints$assets)
}
message("constraint object passed in is a 'v1_constraint' object, updating to v2 specification")
portfolio <- update_constraint_v1tov2(portfolio=tmp_portf, v1_constraint=constraints)
# print.default(portfolio)
}
if(!inherits(constraints, "v1_constraint")){
# Insert the constraints into the portfolio object
portfolio <- insert_constraints(portfolio=portfolio, constraints=constraints)
}
}
if(!is.null(objectives)){
# Insert the objectives into the portfolio object
portfolio <- insert_objectives(portfolio=portfolio, objectives=objectives)
}
#store the call for later
call <- match.call()
if(optimize_method=="random"){
# get any rp related arguments passed in through dots
if(hasArg(rp_method)) rp_method=match.call(expand.dots=TRUE)$rp_method else rp_method="sample"
if(hasArg(eliminate)) eliminate=match.call(expand.dots=TRUE)$eliminate else eliminate=TRUE
if(hasArg(fev)) fev=match.call(expand.dots=TRUE)$fev else fev=0:5
#' call random_portfolios() with constraints and search_size to create matrix of portfolios
if(is.null(rp))
if(inherits(portfolio, "regime.portfolios")){
rp <- rp.regime.portfolios(regime=portfolio, permutations=search_size, rp_method=rp_method, eliminate=eliminate, fev=fev)
} else {
rp <- random_portfolios(portfolio=portfolio, permutations=search_size, rp_method=rp_method, eliminate=eliminate, fev=fev)
}
} else {
rp = NULL
}
if(is.null(training_period)) {if(nrow(R)<36) training_period=nrow(R) else training_period=36}
if (is.null(trailing_periods)){
# define the index endpoints of our periods
ep.i<-endpoints(R,on=rebalance_on)[which(endpoints(R, on = rebalance_on)>=training_period)]
# now apply optimize.portfolio to the periods, in parallel if available
out_list<-foreach(ep=iter(ep.i), .errorhandling='pass', .packages='PortfolioAnalytics') %dopar% {
optimize.portfolio(R[1:ep,], portfolio=portfolio, optimize_method=optimize_method, search_size=search_size, trace=trace, rp=rp, parallel=FALSE, ...=...)
}
} else {
# define the index endpoints of our periods
ep.i<-endpoints(R,on=rebalance_on)[which(endpoints(R, on = rebalance_on)>=training_period)]
# now apply optimize.portfolio to the periods, in parallel if available
out_list<-foreach(ep=iter(ep.i), .errorhandling='pass', .packages='PortfolioAnalytics') %dopar% {
optimize.portfolio(R[(ifelse(ep-trailing_periods>=1,ep-trailing_periods,1)):ep,], portfolio=portfolio, optimize_method=optimize_method, search_size=search_size, trace=trace, rp=rp, parallel=FALSE, ...=...)
}
}
# out_list is a list where each element is an optimize.portfolio object
# at each rebalance date
names(out_list)<-index(R[ep.i])
end_t <- Sys.time()
elapsed_time <- end_t - start_t
if(message) message(c("overall elapsed time:", end_t-start_t))
# out object to return
out <- list()
out$portfolio <- portfolio
out$R <- R
out$call <- call
out$elapsed_time <- elapsed_time
out$opt_rebalancing <- out_list
class(out) <- c("optimize.portfolio.rebalancing")
return(out)
}
#'execute multiple optimize.portfolio calls, presumably in parallel
#'
#' TODO write function to check sensitivity of optimal results by using optimize.portfolio.parallel results
#'
#' This function will not speed up optimization!
#'
#' This function exists to run multiple copies of optimize.portfolio, presumabley in parallel using foreach.
#'
#' This is typically done to test your parameter settings, specifically
#' total population size, but also possibly to help tune your
#' convergence settings, number of generations, stopping criteria,
#' etc.
#'
#' If you want to use all the cores on your multi-core computer, use
#' the parallel version of the apppropriate optimization engine, not
#' this function.
#'
#' @param R an xts, vector, matrix, data frame, timeSeries or zoo object of asset returns
#' @param constraints an object of type "constraints" specifying the constraints for the optimization, see \code{\link{constraint}}
#' @param optimize_method one of "DEoptim" or "random"
#' @param search_size integer, how many portfolios to test, default 20,000
#' @param trace TRUE/FALSE if TRUE will attempt to return additional information on the path or portfolios searched
#' @param \dots any other passthru parameters
#' @param nodes how many processes to run in the foreach loop, default 4
#'
#' @return a list containing the optimal weights, some summary statistics, the function call, and optionally trace information
#' @author Kris Boudt, Peter Carl, Brian G. Peterson
#' @export
optimize.portfolio.parallel <- function(R,constraints,optimize_method=c("DEoptim","random"), search_size=20000, trace=FALSE, ..., nodes=4)
{
stopifnot("package:foreach" %in% search() || require("foreach",quietly=TRUE))
optimize_method=optimize_method[1]
start_t<-Sys.time()
#store the call for later
call <- match.call()
opt_out_list<-foreach(1:nodes, packages='PortfolioAnalytics') %dopar% optimize.portfolio(R=R,constraints=constraints,optimize_method=optimize_method, search_size=search_size, trace=trace, ...)
end_t<-Sys.time()
message(c("overall elapsed time:",end_t-start_t))
class(opt_out_list)<-c("optimize.portfolio.parallel")
return(opt_out_list)
}
#TODO write function to compute an efficient frontier of optimal portfolios
###############################################################################
# $Id$
###############################################################################
install.packages('~/GitHub/PortfolioAnalytics, repos = NULL, type = "source')
library(PortfolioAnalytics)
library(quadprog)
library(osqp)
# Data
result <- read.csv("~/GitHub/GSoC/data/.combined.csv")
result <- xts(result[,2:13], order.by = as.Date(as.character(result[,1]), format = "%m/%d/%Y"))
source("~/GitHub/PortfolioAnalytics/R/optimize.portfolio.R")
CTAs <- colnames(result)
GSoC.CTA <- portfolio.spec(assets = CTAs)
GSoC.CTA <- add.constraint(portfolio = GSoC.CTA, type = "weight_sum", min_sum = 1, max_sum = 1)
GSoC.CTA <- add.constraint(portfolio = GSoC.CTA, type = "long_only")
GSoC.CTA <- add.constraint(portfolio = GSoC.CTA, type = "turnover", turnover_target = 0.5)
GSoC.CTA <- add.constraint(portfolio = GSoC.CTA, type = "diversification", div_target = 0.7)
GSoC.CTA <- add.constraint(portfolio = GSoC.CTA, type = "position__limit", 6)
GSoC.CTA <- add.constraint(portfolio = GSoC.CTA, type = "return", return_target = 0.02)
GSoC.CTA <- add.constraint(portfolio = GSoC.CTA, type = "leverage_exposure", leverage=1.6)
GSoC.CTA <- add.objective(GSoC.CTA, type = "return", name = "mean")
GSoC.CTA <- add.objective(GSoC.CTA, type = "risk", name = "StdDev")
final <- optimize.portfolio(R = result, GSoC.CTA, optimize_method = "osqp", verbos = 0)
#osqp is a mathematic solver which has many restrictions
# warning("osqp can only handle box constraints and mean, var/StdDev type objectives")
for (i in names(constraints)) {
if (!i %in% c("min_sum", "max_sum", "min", "max", "return_target")) {
stop("osqp can only solve box and return_target constraints, please choose a different optimize_method.")
}
}
install.packages('~/GitHub/PortfolioAnalytics, repos = NULL, type = "source')
library(PortfolioAnalytics)
library(quadprog)
library(osqp)
# Data
result <- read.csv("~/GitHub/GSoC/data/.combined.csv")
result <- xts(result[,2:13], order.by = as.Date(as.character(result[,1]), format = "%m/%d/%Y"))
source("~/GitHub/PortfolioAnalytics/R/optimize.portfolio.R")
CTAs <- colnames(result)
GSoC.CTA <- portfolio.spec(assets = CTAs)
GSoC.CTA <- add.constraint(portfolio = GSoC.CTA, type = "weight_sum", min_sum = 1, max_sum = 1)
GSoC.CTA <- add.constraint(portfolio = GSoC.CTA, type = "long_only")
GSoC.CTA <- add.constraint(portfolio = GSoC.CTA, type = "turnover", turnover_target = 0.5)
GSoC.CTA <- add.constraint(portfolio = GSoC.CTA, type = "diversification", div_target = 0.7)
GSoC.CTA <- add.constraint(portfolio = GSoC.CTA, type = "position__limit", 6)
GSoC.CTA <- add.constraint(portfolio = GSoC.CTA, type = "return", return_target = 0.02)
GSoC.CTA <- add.constraint(portfolio = GSoC.CTA, type = "leverage_exposure", leverage=1.6)
GSoC.CTA <- add.objective(GSoC.CTA, type = "return", name = "mean")
GSoC.CTA <- add.objective(GSoC.CTA, type = "risk", name = "StdDev")
final <- optimize.portfolio(R = result, GSoC.CTA, optimize_method = "osqp", verbos = 0)
install.packages('~/GitHub/PortfolioAnalytics, repos = NULL, type = "source')
library(PortfolioAnalytics)
library(quadprog)
library(osqp)
# Data
result <- read.csv("~/GitHub/GSoC/data/.combined.csv")
result <- xts(result[,2:13], order.by = as.Date(as.character(result[,1]), format = "%m/%d/%Y"))
source("~/GitHub/PortfolioAnalytics/R/optimize.portfolio.R")
CTAs <- colnames(result)
GSoC.CTA <- portfolio.spec(assets = CTAs)
GSoC.CTA <- add.constraint(portfolio = GSoC.CTA, type = "weight_sum", min_sum = 1, max_sum = 1)
GSoC.CTA <- add.constraint(portfolio = GSoC.CTA, type = "long_only")
GSoC.CTA <- add.constraint(portfolio = GSoC.CTA, type = "return", return_target = 0.02)
GSoC.CTA <- add.objective(GSoC.CTA, type = "return", name = "mean")
GSoC.CTA <- add.objective(GSoC.CTA, type = "risk", name = "StdDev")
final <- optimize.portfolio(R = result, GSoC.CTA, optimize_method = "osqp", verbos = 0)
install.packages('~/GitHub/PortfolioAnalytics, repos = NULL, type = "source')
library(PortfolioAnalytics)
library(quadprog)
library(osqp)
# Data
result <- read.csv("~/GitHub/GSoC/data/.combined.csv")
result <- xts(result[,2:13], order.by = as.Date(as.character(result[,1]), format = "%m/%d/%Y"))
source("~/GitHub/PortfolioAnalytics/R/optimize.portfolio.R")
CTAs <- colnames(result)
GSoC.CTA <- portfolio.spec(assets = CTAs)
GSoC.CTA <- add.constraint(portfolio = GSoC.CTA, type = "weight_sum", min_sum = 1, max_sum = 1)
GSoC.CTA <- add.constraint(portfolio = GSoC.CTA, type = "long_only")
GSoC.CTA <- add.constraint(portfolio = GSoC.CTA, type = "return", return_target = 0.02)
GSoC.CTA <- add.objective(GSoC.CTA, type = "return", name = "mean")
GSoC.CTA <- add.objective(GSoC.CTA, type = "risk", name = "StdDev")
final <- optimize.portfolio(R = result, GSoC.CTA, optimize_method = "osqp", verbos = 0)
View(portfolio$objectives)
install.packages('~/GitHub/PortfolioAnalytics, repos = NULL, type = "source')
library(PortfolioAnalytics)
library(quadprog)
library(osqp)
# Data
result <- read.csv("~/GitHub/GSoC/data/.combined.csv")
result <- xts(result[,2:13], order.by = as.Date(as.character(result[,1]), format = "%m/%d/%Y"))
source("~/GitHub/PortfolioAnalytics/R/optimize.portfolio.R")
CTAs <- colnames(result)
GSoC.CTA <- portfolio.spec(assets = CTAs)
GSoC.CTA <- add.constraint(portfolio = GSoC.CTA, type = "weight_sum", min_sum = 1, max_sum = 1)
GSoC.CTA <- add.constraint(portfolio = GSoC.CTA, type = "long_only")
GSoC.CTA <- add.constraint(portfolio = GSoC.CTA, type = "return", return_target = 0.02)
GSoC.CTA <- add.objective(GSoC.CTA, type = "return", name = "mean")
GSoC.CTA <- add.objective(GSoC.CTA, type = "risk", name = "StdDev")
final <- optimize.portfolio(R = result, GSoC.CTA, optimize_method = "osqp", verbos = 0)
install.packages('~/GitHub/PortfolioAnalytics, repos = NULL, type = "source')
library(PortfolioAnalytics)
library(quadprog)
library(osqp)
# Data
result <- read.csv("~/GitHub/GSoC/data/.combined.csv")
result <- xts(result[,2:13], order.by = as.Date(as.character(result[,1]), format = "%m/%d/%Y"))
source("~/GitHub/PortfolioAnalytics/R/optimize.portfolio.R")
CTAs <- colnames(result)
GSoC.CTA <- portfolio.spec(assets = CTAs)
GSoC.CTA <- add.constraint(portfolio = GSoC.CTA, type = "weight_sum", min_sum = 1, max_sum = 1)
GSoC.CTA <- add.constraint(portfolio = GSoC.CTA, type = "long_only")
GSoC.CTA <- add.constraint(portfolio = GSoC.CTA, type = "return", return_target = 0.02)
GSoC.CTA <- add.objective(GSoC.CTA, type = "return", name = "mean")
GSoC.CTA <- add.objective(GSoC.CTA, type = "risk", name = "StdDev")
final <- optimize.portfolio(R = result, GSoC.CTA, optimize_method = "osqp", verbos = 0)
install.packages('~/GitHub/PortfolioAnalytics, repos = NULL, type = "source')
library(PortfolioAnalytics)
library(quadprog)
library(osqp)
# Data
result <- read.csv("~/GitHub/GSoC/data/.combined.csv")
result <- xts(result[,2:13], order.by = as.Date(as.character(result[,1]), format = "%m/%d/%Y"))
source("~/GitHub/PortfolioAnalytics/R/optimize.portfolio.R")
CTAs <- colnames(result)
GSoC.CTA <- portfolio.spec(assets = CTAs)
GSoC.CTA <- add.constraint(portfolio = GSoC.CTA, type = "weight_sum", min_sum = 1, max_sum = 1)
GSoC.CTA <- add.constraint(portfolio = GSoC.CTA, type = "long_only")
GSoC.CTA <- add.constraint(portfolio = GSoC.CTA, type = "position_limit", max_pos = 3)
GSoC.CTA <- add.constraint(portfolio = GSoC.CTA, type = "diversification", div_target = 0.7)
GSoC.CTA <- add.constraint(portfolio = GSoC.CTA, type = "turnover", turnover_target = 0.2)
GSoC.CTA <- add.objective(GSoC.CTA, type = "return", name = "mean")
GSoC.CTA <- add.objective(GSoC.CTA, type = "risk", name = "StdDev")
final <- optimize.portfolio(R = result, GSoC.CTA, optimize_method = "osqp", verbos = 0)
install.packages('~/GitHub/PortfolioAnalytics, repos = NULL, type = "source')
library(PortfolioAnalytics)
library(quadprog)
library(osqp)
# Data
result <- read.csv("~/GitHub/GSoC/data/.combined.csv")
result <- xts(result[,2:13], order.by = as.Date(as.character(result[,1]), format = "%m/%d/%Y"))
source("~/GitHub/PortfolioAnalytics/R/optimize.portfolio.R")
CTAs <- colnames(result)
GSoC.CTA <- portfolio.spec(assets = CTAs)
GSoC.CTA <- add.constraint(portfolio = GSoC.CTA, type = "weight_sum", min_sum = 1, max_sum = 1)
GSoC.CTA <- add.constraint(portfolio = GSoC.CTA, type = "return", return_target = 0.007)
# GSoC.CTA <- add.constraint(portfolio = GSoC.CTA, type = "position_limit", max_pos = 3)
# GSoC.CTA <- add.constraint(portfolio = GSoC.CTA, type = "diversification", div_target = 0.7)
# GSoC.CTA <- add.constraint(portfolio = GSoC.CTA, type = "turnover", turnover_target = 0.2)
GSoC.CTA <- add.objective(GSoC.CTA, type = "return", name = "mean")
GSoC.CTA <- add.objective(GSoC.CTA, type = "risk", name = "StdDev")
GSoC.CTA <- add.objective(GSoC.CTA, type = "risk", name = "VaR")
final <- optimize.portfolio(R = result, GSoC.CTA, optimize_method = "osqp", verbos = 0)
install.packages('~/GitHub/PortfolioAnalytics, repos = NULL, type = "source')
library(PortfolioAnalytics)
library(quadprog)
library(osqp)
# Data
result <- read.csv("~/GitHub/GSoC/data/.combined.csv")
result <- xts(result[,2:13], order.by = as.Date(as.character(result[,1]), format = "%m/%d/%Y"))
source("~/GitHub/PortfolioAnalytics/R/optimize.portfolio.R")
CTAs <- colnames(result)
GSoC.CTA <- portfolio.spec(assets = CTAs)
GSoC.CTA <- add.constraint(portfolio = GSoC.CTA, type = "weight_sum", min_sum = 1, max_sum = 1)
GSoC.CTA <- add.constraint(portfolio = GSoC.CTA, type = "return", return_target = 0.007)
GSoC.CTA <- add.objective(GSoC.CTA, type = "return", name = "mean")
GSoC.CTA <- add.objective(GSoC.CTA, type = "risk", name = "StdDev")
final <- optimize.portfolio(R = result, GSoC.CTA, optimize_method = "osqp", verbos = 0)
install.packages('~/GitHub/PortfolioAnalytics, repos = NULL, type = "source')
library(PortfolioAnalytics)
library(quadprog)
library(osqp)
# Data
result <- read.csv("~/GitHub/GSoC/data/.combined.csv")
result <- xts(result[,2:13], order.by = as.Date(as.character(result[,1]), format = "%m/%d/%Y"))
CTAs <- colnames(result)
GSoC.CTA <- portfolio.spec(assets = CTAs)
GSoC.CTA <- add.constraint(portfolio = GSoC.CTA, type = "weight_sum", min_sum = 1, max_sum = 1)
GSoC.CTA <- add.constraint(portfolio = GSoC.CTA, type = "return", return_target = 0.007)
GSoC.CTA <- add.objective(GSoC.CTA, type = "return", name = "mean")
GSoC.CTA <- add.objective(GSoC.CTA, type = "risk", name = "StdDev")
final <- optimize.portfolio(R = result, GSoC.CTA, optimize_method = "osqp", verbos = 0)
View(final)
install.packages('C:/Users/Shawn/Documents/GitHub/PortfolioAnalytics, repos = NULL, type = "source')
library(PortfolioAnalytics)
library(quadprog)
library(osqp)
# Data
result <- read.csv("~/GitHub/GSoC/data/.combined.csv")
result <- xts(result[,2:13], order.by = as.Date(as.character(result[,1]), format = "%m/%d/%Y"))
CTAs <- colnames(result)
GSoC.CTA <- portfolio.spec(assets = CTAs)
GSoC.CTA <- add.constraint(portfolio = GSoC.CTA, type = "weight_sum", min_sum = 1, max_sum = 1)
GSoC.CTA <- add.constraint(portfolio = GSoC.CTA, type = "return", return_target = 0.007)
GSoC.CTA <- add.objective(GSoC.CTA, type = "return", name = "mean")
GSoC.CTA <- add.objective(GSoC.CTA, type = "risk", name = "StdDev")
final <- optimize.portfolio(R = result, GSoC.CTA, optimize_method = "osqp", verbos = 0)
View(GSoC.CTA)
install.packages('C:/Users/Shawn/Documents/GitHub/PortfolioAnalytics', repos = NULL, type = "source')
library(PortfolioAnalytics)
library(quadprog)
library(osqp)
# Data
result <- read.csv("~/GitHub/GSoC/data/.combined.csv")
result <- xts(result[,2:13], order.by = as.Date(as.character(result[,1]), format = "%m/%d/%Y"))
CTAs <- colnames(result)
GSoC.CTA <- portfolio.spec(assets = CTAs)
GSoC.CTA <- add.constraint(portfolio = GSoC.CTA, type = "weight_sum", min_sum = 1, max_sum = 1)
GSoC.CTA <- add.constraint(portfolio = GSoC.CTA, type = "return", return_target = 0.007)
GSoC.CTA <- add.objective(GSoC.CTA, type = "return", name = "mean")
GSoC.CTA <- add.objective(GSoC.CTA, type = "risk", name = "StdDev")
final <- optimize.portfolio(R = result, GSoC.CTA, optimize_method = "osqp", verbos = 0)
install.packages('C:/Users/Shawn/Documents/GitHub/PortfolioAnalytics',
repos = NULL, type = "source")
library(PortfolioAnalytics)
library(quadprog)
library(osqp)
# Data
result <- read.csv("~/GitHub/GSoC/data/.combined.csv")
result <- xts(result[,2:13], order.by = as.Date(as.character(result[,1]), format = "%m/%d/%Y"))
CTAs <- colnames(result)
GSoC.CTA <- portfolio.spec(assets = CTAs)
GSoC.CTA <- add.constraint(portfolio = GSoC.CTA, type = "weight_sum", min_sum = 1, max_sum = 1)
GSoC.CTA <- add.constraint(portfolio = GSoC.CTA, type = "return", return_target = 0.007)
GSoC.CTA <- add.objective(GSoC.CTA, type = "return", name = "mean")
GSoC.CTA <- add.objective(GSoC.CTA, type = "risk", name = "StdDev")
final <- optimize.portfolio(R = result, GSoC.CTA, optimize_method = "osqp", verbos = 0)
View(final)
View(final)
View(GSoC.CTA)
install.packages("C:/Users/Shawn/Documents/GitHub/PortfolioAnalytics",
repos = NULL, type = "source")
library(PortfolioAnalytics)
library(quadprog)
library(osqp)
# Data
result <- read.csv("~/GitHub/GSoC/data/.combined.csv")
result <- xts(result[,2:13], order.by = as.Date(as.character(result[,1]), format = "%m/%d/%Y"))
CTAs <- colnames(result)
GSoC.CTA <- portfolio.spec(assets = CTAs)
GSoC.CTA <- add.constraint(portfolio = GSoC.CTA, type = "weight_sum", min_sum = 1, max_sum = 1)
GSoC.CTA <- add.constraint(portfolio = GSoC.CTA, type = "return", return_target = 0.007)
GSoC.CTA <- add.objective(GSoC.CTA, type = "return", name = "mean")
GSoC.CTA <- add.objective(GSoC.CTA, type = "risk", name = "StdDev")
final <- optimize.portfolio(R = result, GSoC.CTA, optimize_method = "osqp", verbos = 0)
View(final)
final[["weights"]]
View(GSoC.CTA)
install.packages("C:/Users/Shawn/Documents/GitHub/PortfolioAnalytics",
repos = NULL, type = "source")
library(PortfolioAnalytics)
library(quadprog)
library(osqp)
# Data
result <- read.csv("~/GitHub/GSoC/data/.combined.csv")
result <- xts(result[,2:13], order.by = as.Date(as.character(result[,1]), format = "%m/%d/%Y"))
CTAs <- colnames(result)
GSoC.CTA <- portfolio.spec(assets = CTAs)
GSoC.CTA <- add.constraint(portfolio = GSoC.CTA, type = "weight_sum", min_sum = 1, max_sum = 1)
GSoC.CTA <- add.constraint(portfolio = GSoC.CTA, type = "return", return_target = 0.007)
GSoC.CTA <- add.objective(GSoC.CTA, type = "return", name = "mean")
GSoC.CTA <- add.objective(GSoC.CTA, type = "risk", name = "StdDev")
final <- optimize.portfolio(R = result, GSoC.CTA, optimize_method = "osqp", verbos = 0)
install.packages("C:/Users/Shawn/Documents/GitHub/PortfolioAnalytics",
repos = NULL, type = "source")
library(PortfolioAnalytics)
library(quadprog)
library(osqp)
# Data
result <- read.csv("~/GitHub/GSoC/data/.combined.csv")
result <- xts(result[,2:13], order.by = as.Date(as.character(result[,1]), format = "%m/%d/%Y"))
CTAs <- colnames(result)
GSoC.CTA <- portfolio.spec(assets = CTAs)
GSoC.CTA <- add.constraint(portfolio = GSoC.CTA, type = "weight_sum", min_sum = 1, max_sum = 1)
GSoC.CTA <- add.constraint(portfolio = GSoC.CTA, type = "return", return_target = 0.007)
GSoC.CTA <- add.objective(GSoC.CTA, type = "return", name = "mean")
GSoC.CTA <- add.objective(GSoC.CTA, type = "risk", name = "StdDev")
final <- optimize.portfolio(R = result, GSoC.CTA, optimize_method = "osqp", verbos = 0)
View(GSoC.CTA)
